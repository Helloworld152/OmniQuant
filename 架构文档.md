这是一份完整的**系统架构设计文档 (System Architecture Document, SAD)**。

为了体现项目的“全能接入”和“核心稳固”特性，我为你拟定了一个项目名称：

### **项目名称：OmniQuant (全视量化)**

* **Codename**: `Project Aegis` (神盾计划 —— 寓意核心的风控与稳定性)
* **Slogan**: Unified Protocol, Universal Access. (统一协议，万物互联)

---

# OmniQuant 系统架构设计文档 (v1.0)

## 1. 项目概述 (Overview)

### 1.1 背景

当前量化交易环境日益复杂，交易员往往拥有多个柜台账号（CTP、XTP、IB、Binance），且涉及不同的底层协议。缺乏一个统一的监控终端来聚合实时持仓、资金和订单流，导致风控分散，运维困难。

### 1.2 目标

构建一个高性能、低延迟、分布式的量化监控中台。

* **多协议接入**：底层支持 CTP, XTP 等多种柜台。
* **统一标准**：内部使用 Protobuf 定义统一数据交换格式。
* **实时监控**：从成交发生到 Web 端展示延迟控制在毫秒级。
* **架构解耦**：接入层、核心层、展示层物理隔离，互不影响。

---

## 2. 总体架构图 (System Architecture)

系统采用 **“分层漏斗型”** 架构，数据从左向右流动，频率逐层降低，数据价值逐层升高。

| 层级 | 模块名称 | 技术栈 | 职责 | 通信协议 |
| --- | --- | --- | --- | --- |
| **Layer 1** | **Gateways (接入层)** | **C++17** | 负责“脏活累活”。连接柜台，清洗数据，标准化输出。 | ZeroMQ (PUSH) |
| **Layer 2** | **Core Router (核心层)** | **Rust** | 负责“大脑”。多路复用，状态聚合，数据增强，风控路由。 | ZeroMQ (PULL)  RabbitMQ |
| **Layer 3** | **Message Bus (总线层)** | **RabbitMQ** | 负责“快递”。削峰填谷，可靠投递，解耦核心与Web。 | AMQP |
| **Layer 4** | **Data Service (服务层)** | **Python** | 负责“业务”。消费MQ，更新Redis快照，落库Postgres，WebSocket推送。 | AMQP  WebSocket |
| **Layer 5** | **Dashboard (展示层)** | **Vue 3** | 负责“交互”。实时渲染行情、持仓表格。 | WebSocket / HTTP |

---

## 3. 详细模块设计 (Module Design)

### 3.1 核心协议库 (`omni_protocol`)

* **定位**：整个系统的“普通话”，所有模块必须引用的公共依赖。
* **技术**：Google Protocol Buffers (proto3)。
* **核心定义 (`trade.proto`)**:
```protobuf
syntax = "proto3";
package omni;

// 统一事件包
message EventFrame {
    int64 timestamp_ns = 1;
    string source_id = 2; // e.g., "ctp_simnow_01"
    oneof payload {
        MarketData tick = 3;
        OrderUpdate order = 4;
        TradeUpdate trade = 5;
        AccountUpdate account = 6;
    }
}
// ... OrderUpdate, TradeUpdate 等的具体定义

```



### 3.2 接入网关 (`omni_gateway_ctp`)

* **语言**：C++ 17
* **核心库**：`CTP API`, `cppzmq`, `protobuf`
* **设计模式**：
* **独立进程**：每个账号一个进程，防止单点崩溃。
* **无状态**：网关不维护持仓，只负责透传 `OnRtnTrade` / `OnRtnOrder`。
* **Fire & Forget**：使用 ZMQ PUSH 模式发送数据，不等待回执，保证 CTP 回调线程不阻塞。


* **异常处理**：CTP 断线自动重连，重连后发送 `StatusEvent: CONNECTED` 事件。

### 3.3 核心整合器 (`omni_core_rust`)

* **语言**：Rust
* **核心库**：`tokio`, `zmq`, `lapin` (RabbitMQ), `prost`
* **核心职责**：
1. **ZMQ Server**：绑定 `ipc:///tmp/omni.sock` (或 TCP)，接收所有 Gateway 的推流。
2. **数据富化 (Enrichment)**：
* 收到 CTP 的 `rb2405`，在内存 Map 中查出 `Exchange=SHFE`, `Multiplier=10`，补全数据。


3. **风控/路由 (可选)**：在此处拦截异常高频的报单（即使只是监控系统，预留此接口非常重要）。
4. **MQ 投递**：将清洗后的 Protobuf 数据序列化，Publish 到 RabbitMQ 的 `amq.topic` Exchange。



### 3.4 业务后端 (`omni_backend_py`)

* **语言**：Python 3.10+
* **框架**：FastAPI + Uvicorn
* **核心组件**：
* **Consumer Worker**：后台进程 (`asyncio`) 监听 RabbitMQ。
* **Redis Cache**：
* 实时维护 `Position:{AccountID}` 的 Hash 结构。
* 目的：前端 F5 刷新页面时，直接从 Redis 读“当前状态”，不需要去翻数据库。


* **WebSocket Manager**：维护前端连接，支持按频道订阅（如 `sub:account_01`）。


* **持久化**：使用 `TimescaleDB` (基于 PostgreSQL) 存储历史 Tick 和 委托记录。

---

## 4. 数据流转图 (Pipeline)

以“**CTP 成交一笔 RB2405**”为例：

1. **Exchange**: 上期所撮合成功。
2. **Gateway (C++)**:
* `OnRtnTrade` 收到回调。
* 封装为 `EventFrame` (Protobuf)。
* `zmq_send(frame)` -> **耗时 < 10us**。


3. **Core (Rust)**:
* `zmq_recv` 收到字节流。
* 解析 Protobuf，打上 Log。
* `mq_publish("trade.ctp.acc01", frame)` -> **耗时 < 50us**。


4. **Message Bus**: RabbitMQ 路由消息。
5. **Backend (Python)**:
* `on_message` 收到消息。
* 更新 Redis: `HINCRBY pos:rb2405 volume 1`。
* WebSocket 广播: `ws.send_json({...})` -> **耗时 ~1ms**。


6. **Browser (Vue)**:
* Vue 收到 JSON。
* DOM Diff 更新，持仓数字闪烁绿色。



---

## 5. 工程目录结构 (Repository Layout)

```text
OmniQuant/
├── 📄 README.md                # 项目总文档
├── 📄 docker-compose.yml       # 一键启动 Infra (Redis, RabbitMQ, Postgres)
│
├── 📁 00_protocol/             # [通用] 协议定义
│   ├── omni.proto
│   └── scripts/                # 编译脚本 (gen_cpp, gen_rust, gen_py)
│
├── 📁 01_gateway_ctp/          # [C++] CTP 接入网关
│   ├── src/
│   ├── lib/ (CTP SDK)
│   └── CMakeLists.txt
│
├── 📁 02_core_router/          # [Rust] 核心整合器
│   ├── src/
│   │   ├── main.rs             # 入口
│   │   └── engine.rs           # 处理逻辑
│   └── Cargo.toml
│
├── 📁 03_backend_api/          # [Python] Web 后端 & WS
│   ├── app/
│   │   ├── main.py             # FastAPI App
│   │   ├── consumer.py         # MQ 消费者
│   │   └── manager.py          # WebSocket 管理
│   └── requirements.txt
│
└── 📁 04_web_dashboard/        # [Vue] 前端界面
    ├── src/
    └── package.json
    

```

---

## 6. 开发路线图 (Roadmap)

### Phase 1: 骨架搭建 (The Skeleton)

* [ ] 定义 `omni.proto` (Tick, Order, Trade)。
* [ ] 搭建 RabbitMQ 和 Redis Docker。
* [ ] **Rust Core**: 写一个简单的 ZMQ Pull -> Log Print -> MQ Publish 的链路。
* [ ] **C++ Gateway**: 写一个模拟器 (Mock)，每秒发一个模拟数据给 Rust。
* [ ] **Verification**: 在 RabbitMQ 管理后台能看到消息在跳动。

### Phase 2: 真实接入 (The Flesh)

* [ ] **C++ Gateway**: 替换 Mock，接入真实 CTP API (SimNow 环境)。
* [ ] **Python Backend**: 完成 RabbitMQ 消费逻辑，实现 WebSocket 推送 demo。
* [ ] **Frontend**: 用 Vue 写一个简单的 `<ul>` 列表，把收到的数据 print 在网页上。

### Phase 3: 状态与持久化 (The Brain)

* [ ] **Redis**: 后端实现持仓/资金的累加逻辑，支持网页刷新数据不丢。
* [ ] **Postgres**: 数据入库。
* [ ] **UI**: 完善表格组件 (Ag-Grid)，支持红涨绿跌，多账号切换。

---

### 7. 下一步建议

你可以直接复制上面的 **目录结构** 创建文件夹，然后从 **Phase 1** 开始。
需要我先为你生成 **Phase 1** 核心的 `omni.proto` 文件内容吗？